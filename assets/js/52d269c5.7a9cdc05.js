"use strict";(self.webpackChunkignite_cookbook=self.webpackChunkignite_cookbook||[]).push([[5292],{9220:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var s=t(7624),i=t(2172);const o={title:"Authentication with Supabase",description:"How to implement authentication with your React Native project using Supabase as the backend.",tags:["authentication","supabase","login","signup","session"],last_update:{author:"Nick Morgan (@morganick)",publish_date:new Date("2024-04-12T00:00:00.000Z")}},r=void 0,a={id:"recipes/Authentication",title:"Authentication with Supabase",description:"How to implement authentication with your React Native project using Supabase as the backend.",source:"@site/docs/recipes/Authentication.md",sourceDirName:"recipes",slug:"/recipes/Authentication",permalink:"/docs/recipes/Authentication",draft:!1,unlisted:!1,tags:[{label:"authentication",permalink:"/docs/tags/authentication"},{label:"supabase",permalink:"/docs/tags/supabase"},{label:"login",permalink:"/docs/tags/login"},{label:"signup",permalink:"/docs/tags/signup"},{label:"session",permalink:"/docs/tags/session"}],version:"current",lastUpdatedBy:"Nick Morgan (@morganick)",lastUpdatedAt:1718898689,formattedLastUpdatedAt:"Jun 20, 2024",frontMatter:{title:"Authentication with Supabase",description:"How to implement authentication with your React Native project using Supabase as the backend.",tags:["authentication","supabase","login","signup","session"],last_update:{author:"Nick Morgan (@morganick)",publish_date:"2024-04-12T00:00:00.000Z"}},sidebar:"mainSidebar",previous:{title:"Extracting Apollo Client's Cache in Reactotron",permalink:"/docs/recipes/ApolloClientCache"},next:{title:"CircleCI CD Setup - React Native",permalink:"/docs/recipes/CircleCIRNSetup"}},c={},l=[{value:"Overview",id:"overview",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Starting Point",id:"starting-point",level:2},{value:"Build Initial Sign In Screen",id:"build-initial-sign-in-screen",level:2},{value:"Environment Config",id:"environment-config",level:2},{value:"Dependencies",id:"dependencies",level:2},{value:"Session Storage",id:"session-storage",level:2},{value:"Encrypting the User Session",id:"encrypting-the-user-session",level:3},{value:"Creating and Managing the Session",id:"creating-and-managing-the-session",level:2},{value:"Initializing the Supabase Client",id:"initializing-the-supabase-client",level:3},{value:"Signing Up &amp; Signing In",id:"signing-up--signing-in",level:3},{value:"Creating Authentication Context &amp; Provider",id:"creating-authentication-context--provider",level:4},{value:"Signing Out",id:"signing-out",level:3},{value:"Listening for Session Changes",id:"listening-for-session-changes",level:3},{value:"Loading States",id:"loading-states",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Form &amp; Input Affordances",id:"form--input-affordances",level:2},{value:"Keyboard Type &amp; Auto Complete",id:"keyboard-type--auto-complete",level:3},{value:"Keyboard Flow",id:"keyboard-flow",level:3},{value:"Show Password",id:"show-password",level:3},{value:"\ud83c\udf89 Congratulations!",id:"-congratulations",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.M)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Many applications require an external service to authenticate the user. Setting up authentication for your application can feel daunting. Where do I start? What data do I need from my users? What service(s) should or could I use? What are the signup, signin, and other user flows that I'll need?"}),"\n",(0,s.jsxs)(n.p,{children:["This recipe is going to use ",(0,s.jsx)(n.a,{href:"https://supabase.com",children:"Supabase"})," as the backend. We'll build some primitives that will allow you to customize the authentication to your needs or existing backend service as well."]}),"\n",(0,s.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,s.jsxs)(n.p,{children:["Since we're using ",(0,s.jsx)(n.a,{href:"https://supabase.com",children:"Supabase"})," for our backend, it is assumed that you have an account there. We're going to need two pieces of information from that account the project URL and anonymous public key. (Inside your Supabase account, ",(0,s.jsx)(n.a,{href:"https://supabase.com/dashboard/project/_/settings/api",children:"visit the API credentials section"}),".)"]}),"\n",(0,s.jsx)(n.h2,{id:"starting-point",children:"Starting Point"}),"\n",(0,s.jsx)(n.p,{children:"We're going to start from a freshly ignited project without any of the boilerplate screens:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",metastring:'title="Terminal"',children:"bunx ignite-cli@latest new AuthRecipe --workflow=cng --remove-demo --git --install-deps --packager=bun\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Notice we're using ",(0,s.jsx)(n.a,{href:"https://docs.infinite.red/ignite-cli/expo/CNG/",children:"Expo Continuous Native Generation (CNG)"}),". We're also using ",(0,s.jsx)(n.code,{children:"bun"})," in this recipe, but feel free to change that to the package manager of your choice. ",(0,s.jsxs)(n.a,{href:"https://bun.sh",children:["Read more about ",(0,s.jsx)(n.code,{children:"bun"})]})]})}),"\n",(0,s.jsx)(n.p,{children:"Once the app is ignited \ud83d\udd25, we can make sure everything is working by running the app:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",metastring:'title="Terminal"',children:"cd AuthRecipe\nbun run ios\n"})}),"\n",(0,s.jsxs)(n.p,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Checkpoint:"})," The iOS simulator should open up to the welcome screen of the application."]}),"\n",(0,s.jsx)(n.h2,{id:"build-initial-sign-in-screen",children:"Build Initial Sign In Screen"}),"\n",(0,s.jsxs)(n.p,{children:["We'll use the ",(0,s.jsx)(n.a,{href:"https://docs.infinite.red/ignite-cli/concept/Generators/",children:"ignite generators"})," to generate the Sign In screen:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",metastring:'title="Terminal"',children:"bunx ignite-cli@latest generate screen SignIn\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"bunx"})," auto-installs and runs packages from npm. It's Bun's equivalent of ",(0,s.jsx)(n.code,{children:"npx"})," or ",(0,s.jsx)(n.code,{children:"yarn dlx"}),"."]})}),"\n",(0,s.jsx)(n.p,{children:"Replace the contents of that screen with the following:"}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"SignInScreen.tsx"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",metastring:'title="/app/screens/SignInScreen.tsx"',children:'import React, { FC, useState } from "react"\nimport { observer } from "mobx-react-lite"\nimport {\n  Image,\n  ImageStyle,\n  Pressable,\n  TextStyle,\n  View,\n  ViewStyle,\n} from "react-native"\nimport { AppStackScreenProps } from "app/navigators"\nimport { Button, Screen, Text, TextField } from "app/components"\nimport { useSafeAreaInsetsStyle } from "app/utils/useSafeAreaInsetsStyle"\nimport { colors, spacing } from "app/theme"\n\nconst logo = require("../../assets/images/logo.png")\n\ninterface SignInScreenProps extends AppStackScreenProps<"SignIn"> {}\n\nexport const SignInScreen: FC<SignInScreenProps> = observer(\n  function SignInScreen() {\n    const $bottomContainerInsets = useSafeAreaInsetsStyle(["bottom"])\n    const [email, setEmail] = useState("")\n    const [password, setPassword] = useState("")\n\n    const onSignIn = () => {\n      // Sign In Flow\n      console.log("Sign In Flow", { email, password })\n    }\n\n    const onSignUp = () => {\n      // Sign Up Flow\n      console.log("Sign Up Flow")\n    }\n\n    const onForgotPassword = () => {\n      // Forgot Password Flow\n      console.log("Forgot Password Flow")\n    }\n\n    return (\n      <Screen\n        contentContainerStyle={$root}\n        preset="auto"\n        safeAreaEdges={["top"]}\n      >\n        <View style={$container}>\n          <View style={$topContainer}>\n            <Image style={$logo} source={logo} resizeMode="contain" />\n          </View>\n          <View style={[$bottomContainer, $bottomContainerInsets]}>\n            <View>\n              <TextField\n                containerStyle={$textField}\n                label="Email"\n                autoCapitalize="none"\n                defaultValue={email}\n                onChangeText={setEmail}\n              />\n              <TextField\n                containerStyle={$textField}\n                label="Password"\n                autoCapitalize="none"\n                defaultValue={password}\n                secureTextEntry\n                onChangeText={setPassword}\n              />\n            </View>\n            <View>\n              <Button onPress={onSignIn}>Sign In</Button>\n              <Pressable style={$forgotPassword} onPress={onForgotPassword}>\n                <Text preset="bold">Forgot Password?</Text>\n              </Pressable>\n              <Text style={$buttonDivider}>- or -</Text>\n              <Button preset="reversed" onPress={onSignUp}>\n                Sign Up\n              </Button>\n            </View>\n            <View style={$cap} />\n          </View>\n        </View>\n      </Screen>\n    )\n  }\n)\n\nconst $root: ViewStyle = {\n  minHeight: "100%",\n  backgroundColor: colors.palette.neutral100,\n}\n\nconst $container: ViewStyle = {\n  backgroundColor: colors.background,\n}\n\nconst $topContainer: ViewStyle = {\n  height: 200,\n  justifyContent: "center",\n  alignItems: "center",\n}\n\nconst $bottomContainer: ViewStyle = {\n  backgroundColor: colors.palette.neutral100,\n  paddingBottom: spacing.xl,\n  paddingHorizontal: spacing.lg,\n}\n\nconst $cap: ViewStyle = {\n  backgroundColor: colors.palette.neutral100,\n  borderTopLeftRadius: 16,\n  borderTopRightRadius: 16,\n  height: spacing.xl,\n  position: "absolute",\n  top: -spacing.xl,\n  left: 0,\n  right: 0,\n}\n\nconst $textField: ViewStyle = {\n  marginBottom: spacing.md,\n}\n\nconst $forgotPassword: ViewStyle = {\n  marginVertical: spacing.md,\n}\n\nconst $buttonDivider: TextStyle = {\n  textAlign: "center",\n  marginVertical: spacing.md,\n}\n\nconst $logo: ImageStyle = {\n  height: 88,\n  width: "100%",\n  marginBottom: spacing.xxl,\n}\n'})})]}),"\n",(0,s.jsxs)(n.p,{children:["In order for us to be able to see this new Sign In screen, let's add an ",(0,s.jsx)(n.code,{children:"isAuthenticated"}),' conditional to show the "Welcome" screen when the user is signed in and the "Sign In" screen when they are not.']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="/app/navigators/AppNavigator.tsx"',children:'const AppStack = observer(function AppStack() {\n  // success-line\n  const isAuthenticated = false\n  return (\n    <Stack.Navigator\n      screenOptions={{\n        headerShown: false,\n        navigationBarColor: colors.background,\n      }}\n    >\n      // success-line-start\n      {isAuthenticated ? (\n        <>\n          {/** \ud83d\udd25 Your screens go here */}\n          <Stack.Screen name="Welcome" component={Screens.WelcomeScreen} />\n          {/* IGNITE_GENERATOR_ANCHOR_APP_STACK_SCREENS */}\n        </>\n      ) : (\n        <Stack.Screen name="SignIn" component={Screens.SignInScreen} />\n      )}\n      // success-line-end\n    </Stack.Navigator>\n  )\n})\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This should cause the application to refresh and display our new Sign In screen. A couple of things to notice here is that we already have ",(0,s.jsx)(n.code,{children:"onPress"})," handlers for our buttons, ",(0,s.jsx)(n.code,{children:"onSubmitEditing"})," handlers for our inputs, and ",(0,s.jsx)(n.code,{children:"onChangeText"})," wired up for updating the ",(0,s.jsx)(n.code,{children:"email"})," and ",(0,s.jsx)(n.code,{children:"password"})," state."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["For brevity, we're leaving out internationalization for this recipe. For ",(0,s.jsx)(n.code,{children:"TextInput"})," labels, we would normally add those into our translation files under the common section as those words will likely be used often."]})}),"\n",(0,s.jsx)(n.h2,{id:"environment-config",children:"Environment Config"}),"\n",(0,s.jsxs)(n.p,{children:["We're going to take the project URL and the anonymous public key that we gathered from the ",(0,s.jsx)(n.a,{href:"#requirements",children:"Requirements section"})," and add them to our environment."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",metastring:'title="/.env"',children:'EXPO_PUBLIC_SUPABASE_URL="https://<your-project-id>.supabase.co"\nEXPO_PUBLIC_SUPABASE_ANON_KEY="<your-anon-public-key>"\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"Why put these values inside of the environment config? When working on larger projects, it's common to have different URLs and keys for local, testing, staging, and production configurations. You may be thinking \"But that's what the base config is for!\" However, this assumes that every member of your team is using the same backend URL and key for development. Putting this information in the environment reduces code churn when these values change between the different environments and even team members."})}),"\n",(0,s.jsxs)(n.p,{children:["Typically ",(0,s.jsx)(n.code,{children:".env"})," is not commited to version control so let's update our ",(0,s.jsx)(n.code,{children:".gitignore"})," to ignore this file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-git",metastring:'title="/.gitignore"',children:".env\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Expo has great documentation on ",(0,s.jsx)(n.a,{href:"https://docs.expo.dev/guides/environment-variables/",children:"using environment variables"})," if you'd like to know more about how that works."]})}),"\n",(0,s.jsxs)(n.admonition,{type:"warning",children:[(0,s.jsxs)(n.p,{children:["If you're using EAS build to create builds in the cloud, you'll need to make sure the environment variables are available for the profile you want to use. Below the environment variables are added as secrets to EAS from the local ",(0,s.jsx)(n.code,{children:".env"}),":"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",metastring:'title="Terminal"',children:"bunx eas secret:push --scope project --env-file .env\n"})}),(0,s.jsxs)(n.p,{children:["There are multiple options for how to configure your environment variables depending on the sensitivity, profiles, and environments you have. ",(0,s.jsx)(n.a,{href:"https://docs.expo.dev/build-reference/variables/",children:"Read more about environment variables with EAS build."})]})]}),"\n",(0,s.jsx)(n.p,{children:"This allows us to have different configurations for our development, staging, testing, and production environments. For our purposes, we're going to add these values to the base configuration as these props are required for every environment."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="/app/config/config.base.ts"',children:'export interface ConfigBaseProps {\n  persistNavigation: "always" | "dev" | "prod" | "never"\n  catchErrors: "always" | "dev" | "prod" | "never"\n  exitRoutes: string[]\n  // success-line-start\n  supabaseUrl: string\n  supabaseAnonKey: string\n  // success-line-end\n}\n\nexport type PersistNavigationConfig = ConfigBaseProps["persistNavigation"]\n\nconst BaseConfig: ConfigBaseProps = {\n  // This feature is particularly useful in development mode, but\n  // can be used in production as well if you prefer.\n  persistNavigation: "dev",\n\n  /**\n   * Only enable if we\'re catching errors in the right environment\n   */\n  catchErrors: "always",\n\n  /**\n   * This is a list of all the route names that will exit the app if the back button\n   * is pressed while in that screen. Only affects Android.\n   */\n  exitRoutes: ["Welcome"],\n  // success-line-start\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  supabaseUrl: process.env.EXPO_PUBLIC_SUPABASE_URL!,\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  supabaseAnonKey: process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY!,\n  // success-line-end\n}\n\nexport default BaseConfig\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["These new environment variables will not be available until the next time you restart metro either with ",(0,s.jsx)(n.code,{children:"bun run ios"})," or ",(0,s.jsx)(n.code,{children:"bun start"}),"."]})}),"\n",(0,s.jsx)(n.h2,{id:"dependencies",children:"Dependencies"}),"\n",(0,s.jsx)(n.p,{children:"For this recipe we've made some specific choices around the packages that we'll use:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://supabase.com/docs/reference/javascript/installing",children:"@supabase/supabase-js"})," - Supabase client to handle authentication requests, sign up users, token refresh, etc."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/mrousavy/react-native-mmkv",children:"react-native-mmkv"})," - Fast key/value store we'll use for the session."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",metastring:'title="Terminal"',children:"bunx expo install @supabase/supabase-js react-native-mmkv\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Since ",(0,s.jsx)(n.code,{children:"react-native-mmkv"})," has a host platform dependency, we'll need to also rebuild the application with:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",metastring:'title="Terminal"',children:"bun ios\n# or\nbun android\n"})}),"\n",(0,s.jsx)(n.h2,{id:"session-storage",children:"Session Storage"}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"If you're already using Async Storage in your application, you can take advantage of that and skip this section."})}),"\n",(0,s.jsxs)(n.p,{children:["We need a place to store the user's session after they login. This will allow us to log them back in after they close the application or refresh their access token after it has expired. Supabase's client is already setup for Async Storage's API. (e.g. ",(0,s.jsx)(n.code,{children:"getItem"}),", ",(0,s.jsx)(n.code,{children:"setItem"}),", and ",(0,s.jsx)(n.code,{children:"removeItem"}),") We're going to use ",(0,s.jsx)(n.code,{children:"react-native-mmkv"})," as it is not only faster, but has some additional features that we can utilize."]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Initial session storage implementation"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="/app/utils/storage/SessionStorage.ts"',children:'import { MMKV } from "react-native-mmkv"\n\nconst storage = new MMKV({\n  id: "session",\n})\n\n// TODO: Remove this workaround for encryption: https://github.com/mrousavy/react-native-mmkv/issues/665\nstorage.set("workaround", true)\n\n/**\n * A simple wrapper around MMKV that provides a base API\n * that matches AsyncStorage for use with Supabase.\n */\n\n/**\n * Get an item from storage by key\n *\n * @param {string} key of the item to fetch\n * @returns {Promise<string | null>} value for the key as a string or null if not found\n */\nexport async function getItem(key: string): Promise<string | null> {\n  try {\n    return storage.getString(key) ?? null\n  } catch {\n    console.warn(`Failed to get key "${key}" from secure storage`)\n    return null\n  }\n}\n\n/**\n * Sets an item in storage by key\n *\n * @param {string} key of the item to store\n * @param {string} value of the item to store\n */\nexport async function setItem(key: string, value: string): Promise<void> {\n  try {\n    storage.set(key, value)\n  } catch {\n    console.warn(`Failed to set key "${key}" in secure storage`)\n  }\n}\n\n/**\n * Removes a single item from storage by key\n *\n * @param {string} key of the item to remove\n */\nexport async function removeItem(key: string): Promise<void> {\n  try {\n    storage.delete(key)\n  } catch {\n    console.warn(`Failed to remove key "${key}" from secure storage`)\n  }\n}\n'})})]}),"\n",(0,s.jsx)(n.h3,{id:"encrypting-the-user-session",children:"Encrypting the User Session"}),"\n",(0,s.jsxs)(n.p,{children:["If you'd like to encrypt the user's session because it ",(0,s.jsx)(n.a,{href:"https://reactnative.dev/docs/security#storing-sensitive-info",children:"contains sensitive information"}),", you can take advantage of Expo SecureStore and MMKV's encryption. Expo SecureStore will securely store key-value pairs locally on device in the iOS keychain or Android Keystore. The reason we need both is that ",(0,s.jsx)(n.a,{href:"https://docs.expo.dev/versions/latest/sdk/securestore/",children:"Expo SecureStore has a size limit of 2048 bytes"}),". The Supabase session is already larger than 2048 bytes by default so we're going to generate a unique key with Expo Crypto to encrypt the Session Store with MMKV and store that key with Expo SecureStore."]}),"\n",(0,s.jsx)(n.p,{children:"First, we'll need to install those additional dependencies:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",metastring:'title="Terminal"',children:"bunx expo install expo-secure-store expo-crypto\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We'll also need to add Expo SecureStorage to our ",(0,s.jsx)(n.a,{href:"https://docs.expo.dev/versions/latest/sdk/securestore/#configuration-in-appjsonappconfigjs",children:"plugin configuration"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="/app.json"',children:'...\n    "plugins": [\n      "expo-localization",\n      // success-line\n      "expo-secure-store",\n      [\n        "expo-build-properties",\n        {\n          "ios": {\n            "newArchEnabled": false,\n            "flipper": false\n          },\n          "android": {\n            "newArchEnabled": false\n          }\n        }\n      ],\n      "expo-font"\n    ],\n...\n'})}),"\n",(0,s.jsx)(n.p,{children:"Rebuild the application with:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",metastring:'title="Terminal"',children:"bun ios\n# or\nbun android\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now, we can use Expo SecureStore and Expo Crypto to securely generate and store our encrypting key for MMKV:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="/app/utils/storage/SessionStorage.ts"',children:'import { MMKV } from "react-native-mmkv"\n// success-line-start\nimport * as SecureStore from "expo-secure-store"\nimport * as Crypto from "expo-crypto"\n\nconst fetchOrGenerateEncryptionKey = (): string => {\n  const encryptionKey = SecureStore.getItem("session-encryption-key")\n\n  if (encryptionKey) {\n    return encryptionKey\n  } else {\n    const uuid = Crypto.randomUUID()\n    SecureStore.setItem("session-encryption-key", uuid)\n    return uuid\n  }\n}\n// success-line-end\n\nconst storage = new MMKV({\n  id: "session",\n  // success-line\n  encryptionKey: fetchOrGenerateEncryptionKey(),\n})\n\n...\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["If you're using Async Storage and you'd also like to encrypt the user's session, refer to the ",(0,s.jsx)(n.a,{href:"https://supabase.com/blog/react-native-authentication#encrypting-the-user-session",children:"Encrypting the user session section"})," of the Supabase guide."]})}),"\n",(0,s.jsx)(n.h2,{id:"creating-and-managing-the-session",children:"Creating and Managing the Session"}),"\n",(0,s.jsx)(n.p,{children:"There are three pieces that we're going to need to create and manage our session: a hook, context, and provider."}),"\n",(0,s.jsx)(n.h3,{id:"initializing-the-supabase-client",children:"Initializing the Supabase Client"}),"\n",(0,s.jsxs)(n.p,{children:["Let's start by creating the file for the hook to initialize the Supabase client with our environment config and ",(0,s.jsx)(n.code,{children:"SessionStorage"})," we set up earlier:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'showLineNumbers title="/app/services/auth/supabase.ts"',children:'import Config from "app/config"\nimport { createClient } from "@supabase/supabase-js"\nimport * as SessionStorage from "app/utils/storage/SessionStorage"\nimport { AppState } from "react-native"\n\nexport const supabase = createClient(\n  Config.supabaseUrl,\n  Config.supabaseAnonKey,\n  {\n    auth: {\n      storage: SessionStorage,\n      autoRefreshToken: true,\n      detectSessionInUrl: false,\n    },\n  }\n)\n\nexport { type Session, type AuthError } from "@supabase/supabase-js"\n\n/**\n * Tells Supabase to autorefresh the session while the application\n * is in the foreground. (Docs: https://supabase.com/docs/reference/javascript/auth-startautorefresh)\n */\nAppState.addEventListener("change", (nextAppState) => {\n  if (nextAppState === "active") {\n    supabase.auth.startAutoRefresh()\n  } else {\n    supabase.auth.stopAutoRefresh()\n  }\n})\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["If you've opted to use Async Storage, change line 11 above to ",(0,s.jsx)(n.code,{children:"storage: AsyncStorage"}),"."]})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:["Why not use PKCE (pronounced pixy) by setting the ",(0,s.jsx)(n.code,{children:'flowType: "pkce"'}),"?"]}),' It stands for "',(0,s.jsx)(n.strong,{children:"P"}),"roof ",(0,s.jsx)(n.strong,{children:"K"}),"ey for ",(0,s.jsx)(n.strong,{children:"C"}),"ode ",(0,s.jsx)(n.strong,{children:"E"}),'xchange". ',(0,s.jsx)(n.a,{href:"https://supabase.com/blog/supabase-auth-sso-pkce#server-side-and-mobile-auth",children:"Read Supabase's write-up about why they did it and how it works"}),". You'd ecounter this with doing email confirmation for your sign up process as well as password resets. If you decided to turn it on, sign up will produce the console warning \"WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.\", but it will still work. Since we currently have email confirmation disabled, we'll save email confirmation and password reset for a future recipe."]})}),"\n",(0,s.jsx)(n.p,{children:"Since we're allowing the Supabase client to manage session storage, it will automatically persist changes to the session. We've added an event listener to stop refreshing the session when the application is no longer in the foreground and restart it when it returns to the foreground. The Supabase client will then automatically refresh the session as necessary; one less thing that we'll need to handle manually. \ud83d\ude2e\u200d\ud83d\udca8"}),"\n",(0,s.jsx)(n.h3,{id:"signing-up--signing-in",children:"Signing Up & Signing In"}),"\n",(0,s.jsxs)(n.p,{children:["To keep this simple, we're going to use the same form for both. We'll need to create an ",(0,s.jsx)(n.code,{children:"onPress"})," and ",(0,s.jsx)(n.code,{children:"onSubmit"})," handler for the respective actions that are already stubbed out in the ",(0,s.jsx)(n.code,{children:"SignInScreen"}),' we created earlier. You may have more information you\'d like to capture (e.g. name, phone number, password confirmation, etc.) when a user signs up. In such a case, create a separate "Sign Up" screen that captures the additional data.']}),"\n",(0,s.jsx)(n.h4,{id:"creating-authentication-context--provider",children:"Creating Authentication Context & Provider"}),"\n",(0,s.jsx)(n.p,{children:"We're going to be using the session across components, at different depths in our component tree, and with navigation. For this access pattern we'll create a context and provider. This way if that information changes, we'll re-render the entire tree. (e.g. If the user signs out, we'll navigate back to the \"Sign In\" screen automatically.)"}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"Be careful when using contexts as anything that depends on data in the context is going to cause a re-render when the data changes. This can have performance implications if you're re-rendering the entire tree frequently. In the case of authentication, we want to re-render the entire tree when the session is updated as we may need to navigate to the sign in screen if the user's session expires."})}),"\n",(0,s.jsxs)(n.p,{children:["Let's setup our ",(0,s.jsx)(n.code,{children:"AuthContext"})," with our session state, add our ",(0,s.jsx)(n.code,{children:"AuthProvider"}),", and create a ",(0,s.jsx)(n.code,{children:"useAuth"})," hook that will return the value of our context:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="/app/services/auth/useAuth.tsx"',children:'import React, {\n  createContext,\n  PropsWithChildren,\n  useCallback,\n  useContext,\n  useState,\n} from "react"\nimport { Session, supabase } from "./supabase"\nimport { AuthResponse, AuthTokenResponsePassword } from "@supabase/supabase-js"\n\ntype AuthState = {\n  isAuthenticated: boolean\n  token?: Session["access_token"]\n}\n\ntype SignInProps = {\n  email: string\n  password: string\n}\n\ntype SignUpProps = {\n  email: string\n  password: string\n}\n\ntype AuthContextType = {\n  signIn: (props: SignInProps) => Promise<AuthTokenResponsePassword>\n  signUp: (props: SignUpProps) => Promise<AuthResponse>\n} & AuthState\n\nconst AuthContext = createContext<AuthContextType>({\n  isAuthenticated: false,\n  token: undefined,\n  signIn: () => new Promise(() => ({})),\n  signUp: () => new Promise(() => ({})),\n})\n\nexport function useAuth() {\n  const value = useContext(AuthContext)\n\n  if (process.env.NODE_ENV !== "production") {\n    if (!value) {\n      throw new Error("useAuth must be used within an AuthProvider")\n    }\n  }\n\n  return value\n}\n\nexport const AuthProvider = ({ children }: PropsWithChildren) => {\n  const [token, setToken] = useState<AuthState["token"]>(undefined)\n\n  const signIn = useCallback(\n    async ({ email, password }: SignInProps) => {\n      const result = await supabase.auth.signInWithPassword({\n        email,\n        password,\n      })\n\n      if (result.data?.session?.access_token) {\n        setToken(result.data.session.access_token)\n      }\n\n      return result\n    },\n    [supabase]\n  )\n\n  const signUp = useCallback(\n    async ({ email, password }: SignUpProps) => {\n      const result = await supabase.auth.signUp({\n        email,\n        password,\n      })\n\n      if (result.data?.session?.access_token) {\n        setToken(result.data.session.access_token)\n      }\n\n      return result\n    },\n    [supabase]\n  )\n\n  return (\n    <AuthContext.Provider\n      value={{\n        isAuthenticated: !!token,\n        token,\n        signIn,\n        signUp,\n      }}\n    >\n      {children}\n    </AuthContext.Provider>\n  )\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Now that we have those pieces in place, we can wrap our application with the ",(0,s.jsx)(n.code,{children:"AuthProvider"})," so that we can access the ",(0,s.jsx)(n.code,{children:"AuthContext"})," inside of our compontents and navigation:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="/app/app.tsx"',children:'...\nimport { ViewStyle } from "react-native"\n// success-line\nimport { AuthProvider } from "./services/auth/useAuth"\n\n...\n\n  return (\n    // success-line\n    <AuthProvider>\n      <SafeAreaProvider initialMetrics={initialWindowMetrics}>\n        <ErrorBoundary catchErrors={Config.catchErrors}>\n          <GestureHandlerRootView style={$container}>\n            <AppNavigator\n              linking={linking}\n              initialState={initialNavigationState}\n              onStateChange={onNavigationStateChange}\n            />\n          </GestureHandlerRootView>\n        </ErrorBoundary>\n      </SafeAreaProvider>\n    // success-line\n    </AuthProvider>\n  )\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Next, we'll wire up the ",(0,s.jsx)(n.code,{children:"isAuthenticated"})," to the ",(0,s.jsx)(n.code,{children:"useAuth"})," hook inside our ",(0,s.jsx)(n.code,{children:"AppStack"}),' to show the "Sign In" screen when the user is not authenticated and the "Welcome" screen when the are:']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="/app/navigators/AppNavigator.tsx"',children:'...\n\nimport { colors } from "app/theme"\n// success-line\nimport { useAuth } from "app/services/auth/useAuth"\n\n...\n\nconst AppStack = observer(function AppStack() {\n  // error-line\n  const isAuthenticated = false\n  // success-line\n  const { isAuthenticated } = useAuth()\n  return (\n    <Stack.Navigator screenOptions={{ headerShown: false, navigationBarColor: colors.background }}>\n      {isAuthenticated ? (\n        <>\n          {/** \ud83d\udd25 Your screens go here */}\n          <Stack.Screen name="Welcome" component={Screens.WelcomeScreen} />\n          {/* IGNITE_GENERATOR_ANCHOR_APP_STACK_SCREENS */}\n        </>\n      ) : (\n        <Stack.Screen name="SignIn" component={Screens.SignInScreen} />\n      )}\n    </Stack.Navigator>\n  )\n})\n\n...\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Lastly, let's wire up the ",(0,s.jsx)(n.code,{children:"SignInScreen"})," to use ",(0,s.jsx)(n.code,{children:"signIn"})," and ",(0,s.jsx)(n.code,{children:"signUp"})," from the ",(0,s.jsx)(n.code,{children:"useSession"})," hook:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="/app/screens/SignInScreen.tsx"',children:'...\nimport { colors, spacing } from "app/theme"\n// success-line\nimport { useAuth } from "app/services/auth/useAuth"\n\n...\nexport const SignInScreen: FC<SignInScreenProps> = observer(function SignInScreen() {\n  const $bottomContainerInsets = useSafeAreaInsetsStyle(["bottom"])\n  // success-line\n  const { signIn, signUp } = useAuth()\n  const [email, setEmail] = useState("")\n  const [password, setPassword] = useState("")\n\n  const passwordInput = React.useRef<TextInput>(null)\n\n  const onSignIn = () => {\n    // error-line-start\n    // Sign In Flow\n    console.log("Sign In Flow", { email, password })\n    // error-line-end\n    // success-line\n    signIn({ email, password })\n  }\n\n  const onSignUp = () => {\n    // error-line-start\n    // Sign Up Flow\n    console.log("Sign Up Flow")\n    // error-line-end\n    // success-line\n    signUp({ email, password })\n  }\n\n...\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["Before you try to sign in for the first time, we'll want to make sure that email confirmation is ",(0,s.jsx)(n.strong,{children:"turned off"})," inside of this Supabase project. With email confirmation turned on, creating a user will only return the user and ",(0,s.jsx)(n.strong,{children:"not return the session"}),". For now, ",(0,s.jsx)(n.a,{href:"https://supabase.com/dashboard/project/_/auth/providers",children:"disable email confirmation in your project"}),' by clicking on Authentication > Providers > Email and toggling "Confirm Email" to off.']})}),"\n",(0,s.jsxs)(n.p,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Checkpoint:"}),' With those changes you should be able to enter an email and password and press the "Sign Up" button which will create a user, return the session, and navigate you to the "Welcome" screen.']}),"\n",(0,s.jsx)(n.h3,{id:"signing-out",children:"Signing Out"}),"\n",(0,s.jsxs)(n.p,{children:["Oh no! We're stuck in the signed in state. No dark patterns here! Let's fix that by adding the ",(0,s.jsx)(n.code,{children:"signOut"})," action to our ",(0,s.jsx)(n.code,{children:"useAuth"})," hook:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="/app/services/auth/useAuth.tsx"',children:"...\ntype AuthContextType = {\n  signIn: (props: SignInProps) => Promise<AuthTokenResponsePassword>\n  signUp: (props: SignUpProps) => Promise<AuthResponse>\n  // success-line\n  signOut: () => void\n} & AuthState\n\nconst AuthContext = createContext<AuthContextType>({\n  isAuthenticated: false,\n  token: undefined,\n  signIn: () => new Promise(() => ({})),\n  signUp: () => new Promise(() => ({})),\n  // success-line\n  signOut: () => undefined,\n})\n...\nexport const AuthProvider = ({ children }: PropsWithChildren) => {\n...\n  // success-line-start\n  const signOut = useCallback(async () => {\n    await supabase.auth.signOut()\n    setToken(undefined)\n  }, [supabase])\n  // success-line-end\n\n  return (\n    <AuthContext.Provider\n      value={{\n        isAuthenticated: !!token,\n        token,\n        signIn,\n        signUp,\n        // success-line\n        signOut,\n      }}\n    >\n      {children}\n    </AuthContext.Provider>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:'Now, we\'ll add the "Sign Out" button and update the screen to show some data from the session:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="/app/screens/WelcomeScreen.tsx"',children:'import { observer } from "mobx-react-lite"\nimport React, { FC } from "react"\nimport { Image, ImageStyle, TextStyle, View, ViewStyle } from "react-native"\n// error-line\nimport { Text } from "app/components"\n// success-line\nimport { Button, Text } from "app/components"\nimport { isRTL } from "../i18n"\nimport { AppStackScreenProps } from "../navigators"\nimport { colors, spacing } from "../theme"\nimport { useSafeAreaInsetsStyle } from "../utils/useSafeAreaInsetsStyle"\n// success-line\nimport { useAuth } from "app/services/auth/useAuth"\n\nconst welcomeLogo = require("../../assets/images/logo.png")\nconst welcomeFace = require("../../assets/images/welcome-face.png")\n\ninterface WelcomeScreenProps extends AppStackScreenProps<"Welcome"> {}\n\nexport const WelcomeScreen: FC<WelcomeScreenProps> = observer(\n  function WelcomeScreen() {\n    const $bottomContainerInsets = useSafeAreaInsetsStyle(["bottom"])\n    const { signOut } = useAuth()\n\n    return (\n      <View style={$container}>\n        <View style={$topContainer}>\n          <Image\n            style={$welcomeLogo}\n            source={welcomeLogo}\n            resizeMode="contain"\n          />\n          <Text\n            testID="welcome-heading"\n            style={$welcomeHeading}\n            // error-line\n            tx="welcomeScreen.readyForLaunch"\n            // success-line\n            text="Congratulations \ud83c\udf89 You\'re signed in!"\n            preset="heading"\n          />\n          <Text tx="welcomeScreen.exciting" preset="subheading" />\n          <Image\n            style={$welcomeFace}\n            source={welcomeFace}\n            resizeMode="contain"\n          />\n        </View>\n        <View style={[$bottomContainer, $bottomContainerInsets]}>\n          // error-line\n          <Text tx="welcomeScreen.postscript" size="md" />\n          // success-line\n          <Button onPress={signOut}>Sign Out</Button>\n        </View>\n      </View>\n    )\n  }\n)\n'})}),"\n",(0,s.jsx)(n.p,{children:'If you\'re anything like me, you may have noticed that the screen transition always sliding to the left seems off. The way we mentally feel about "Sign In" and "Sign Out" is entering and existing. The way the animations are working right now, it feels like we just keep signing in. Let\'s adjust that navigation transition:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="/app/navigators/AppNavigator.tsx"',children:'...\nconst AppStack = observer(function AppStack() {\n  const { isAuthenticated } = useAuth()\n  return (\n    <Stack.Navigator screenOptions={{ headerShown: false, navigationBarColor: colors.background }}>\n      {isAuthenticated ? (\n        <>\n          {/** \ud83d\udd25 Your screens go here */}\n          <Stack.Screen name="Welcome" component={Screens.WelcomeScreen} />\n          {/* IGNITE_GENERATOR_ANCHOR_APP_STACK_SCREENS */}\n        </>\n      ) : (\n        <Stack.Screen\n          name="SignIn"\n          component={Screens.SignInScreen}\n          // success-line\n          options={{ animationTypeForReplace: "pop" }}\n        />\n      )}\n    </Stack.Navigator>\n  )\n})\n...\n'})}),"\n",(0,s.jsx)(n.p,{children:"All is right with the world again. \ud83d\ude05"}),"\n",(0,s.jsxs)(n.p,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Checkpoint:"})," You should now be able to sign up, sign in, and sign out. This is a good time to commit what you have."]}),"\n",(0,s.jsx)(n.h3,{id:"listening-for-session-changes",children:"Listening for Session Changes"}),"\n",(0,s.jsxs)(n.p,{children:["As noted earlier, we're listening for changes in the ",(0,s.jsx)(n.code,{children:"AppState"})," for when the application comes back to the foreground. However, there are other session events we should listen for such as signing out of all devices, user updates, password recovery, etc. ",(0,s.jsx)(n.a,{href:"https://supabase.com/docs/reference/javascript/auth-onauthstatechange",children:'Checkout "Listen to Auth Events" in the Supabase docs for detailed information about each event.'})]}),"\n",(0,s.jsx)(n.p,{children:"To listen for these authentication state changes, we can subscribe to those events when the application initially loads."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="/app/services/auth/useAuth.tsx"',children:'...\n// error-line\nimport React, { createContext, PropsWithChildren, useCallback, useContext, useState } from "react"\n// success-line\nimport React, { createContext, PropsWithChildren, useCallback, useContext, useEffect, useState } from "react"\n...\nexport const AuthProvider = ({ children }: PropsWithChildren) => {\n  const [token, setToken] = useState<AuthState["token"]>(undefined)\n\n  // success-line-start\n  useEffect(() => {\n    const {\n      data: { subscription },\n    } = supabase.auth.onAuthStateChange((event, session) => {\n      switch (event) {\n        case "SIGNED_OUT":\n          setToken(undefined)\n          break\n        case "INITIAL_SESSION":\n        case "SIGNED_IN":\n        case "TOKEN_REFRESHED":\n          setToken(session?.access_token)\n          break\n        default:\n        // no-op\n      }\n    })\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [supabase])\n  // success-line-end\n...\n'})}),"\n",(0,s.jsx)(n.h2,{id:"loading-states",children:"Loading States"}),"\n",(0,s.jsxs)(n.p,{children:["Those with a keen eye will notice that our ",(0,s.jsx)(n.code,{children:"AuthContext"})," does not contain loading states. There's a reason for that. Loading states should be local to the UI that initiated them. Using loading states can make your application feel more responsive and set proper expectations for the user. You may have also noticed that our ",(0,s.jsx)(n.code,{children:"signIn"}),' function returns a promise. Let\'s add a loading state for the "Sign In" flow and (a)wait for the sign up request to complete:']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="/app/screens/SignInScreen.tsx"',children:'...\nexport const SignInScreen: FC<SignInScreenProps> = observer(function SignInScreen() {\n  const $bottomContainerInsets = useSafeAreaInsetsStyle(["bottom"])\n  const { signIn, signUp } = useAuth()\n  const [email, setEmail] = useState("")\n  const [password, setPassword] = useState("")\n  // success-line\n  const [isSigningIn, setIsSigningIn] = useState(false)\n\n  // error-line-start\n  const onSignIn = () => {\n    signIn({ email, password })\n  // error-line-end\n  // success-line-start\n  const onSignIn = async () => {\n    try {\n      setIsSigningIn(true)\n      await signIn({ email, password })\n    } finally {\n      setIsSigningIn(false)\n    }\n  // success-line-end\n  }\n  ...\n            // error-line\n            <Button onPress={onSignIn}>Sign In</Button>\n            // success-line-start\n            <Button onPress={onSignIn}>\n              {isSigningIn ? "Signing In..." : "Sign In"}\n            </Button>\n            // success-line-end\n            ...\n\n'})}),"\n",(0,s.jsx)(n.p,{children:"\ud83d\ude4c Easy, let's do the same thing for sign up:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="/app/screens/SignInScreen.tsx"',children:'...\nexport const SignInScreen: FC<SignInScreenProps> = observer(function SignInScreen() {\n  const $bottomContainerInsets = useSafeAreaInsetsStyle(["bottom"])\n  const { signIn, signUp } = useAuth()\n  const [email, setEmail] = useState("")\n  const [password, setPassword] = useState("")\n  const [isSigningIn, setIsSigningIn] = useState(false)\n  // success-line\n  const [isSigningUp, setIsSigningUp] = useState(false)\n\n  const onSignIn = async () => {\n    try {\n      setIsSigningIn(true)\n      await signIn({ email, password })\n    } finally {\n      setIsSigningIn(false)\n    }\n  }\n\n  // error-line-start\n  const onSignUp = () => {\n    signUp({ email, password })\n  // error-line-end\n  // success-line-start\n  const onSignUp = async () => {\n    try {\n      setIsSigningUp(true)\n      await signUp({ email, password })\n    } finally {\n      setIsSigningUp(false)\n    }\n  // success-line-end\n  }\n  ...\n            // error-line\n            <Button preset="reversed" onPress={onSignUp}>Sign Up</Button>\n            // success-line-start\n            <Button preset="reversed" onPress={onSignUp}>\n              {isSigningUp ? "Signing Up..." : "Sign Up"}\n            </Button>\n            // success-line-end\n            ...\n\n'})}),"\n",(0,s.jsx)(n.p,{children:"Lastly, should a user be able to sign up and sign in at the same time? No. We can use a combined loading state to disable the buttons and make the text inputs read only while we are either signing in or signing up:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="/app/screens/SignInScreen.tsx"',children:'...\nexport const SignInScreen: FC<SignInScreenProps> = observer(function SignInScreen() {\n  const $bottomContainerInsets = useSafeAreaInsetsStyle(["bottom"])\n  const { signIn, signUp } = useAuth()\n  const [email, setEmail] = useState("")\n  const [password, setPassword] = useState("")\n  const [isSigningIn, setIsSigningIn] = useState(false)\n  const [isSigningUp, setIsSigningUp] = useState(false)\n  // success-line\n  const isLoading = isSigningIn || isSigningUp\n...\n          <View>\n            <TextField\n              containerStyle={$textField}\n              label="Email"\n              autoCapitalize="none"\n              defaultValue={email}\n              onChangeText={setEmail}\n              // success-line\n              readOnly={isLoading}\n            />\n            <TextField\n              containerStyle={$textField}\n              label="Password"\n              autoCapitalize="none"\n              defaultValue={password}\n              secureTextEntry\n              onChangeText={setPassword}\n              // success-line\n              readOnly={isLoading}\n            />\n          </View>\n          <View>\n            // success-line\n            <Button onPress={onSignIn} disabled={isLoading}>\n              {isSigningIn ? "Signing In..." : "Sign In"}\n            </Button>\n            // success-line\n            <Pressable style={$forgotPassword} onPress={onForgotPassword} disabled={isLoading}>\n              <Text preset="bold">Forgot Password?</Text>\n            </Pressable>\n            <Text style={$buttonDivider}>- or -</Text>\n            // success-line\n            <Button preset="reversed" onPress={onSignUp} disabled={isLoading}>\n              {isSigningUp ? "Signing Up..." : "Sign Up"}\n            </Button>\n          </View>\n        </View>\n'})}),"\n",(0,s.jsx)(n.p,{children:"No more double sign up or sign in requests. This bit of defensive programming is minimal additional effort that saves you and your team time down the road as your users will not encounter that issue."}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.p,{children:"What would you expect to happen if the user submitted an empty form for Sign In or Sign Up? What if they submit an email and no password or vice versa? What if there's a network issue? What if there's a service outage? How can we allow the user to self diagnose the issue if it's something they can correct? That's where good error handling comes in. So let's start with errors on form submission."}),"\n",(0,s.jsx)(n.p,{children:"There's a reason that we return the result to the caller so we can present these errors locally to the user."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="/app/screens/SignInScreen.tsx"',children:'...\nexport const SignInScreen: FC<SignInScreenProps> = observer(function SignInScreen() {\n  const $bottomContainerInsets = useSafeAreaInsetsStyle(["bottom"])\n  const { signIn, signUp } = useAuth()\n  const [email, setEmail] = useState("")\n  const [password, setPassword] = useState("")\n  // success-line\n  const [error, setError] = useState<string | undefined>(undefined)\n...\n  const onSignIn = async () => {\n    try {\n      setIsSigningIn(true)\n      // success-line\n      setError(undefined)\n\n      // error-line\n      await signIn({ email, password })\n      // success-line-start\n      const { error } = await signIn({ email, password })\n      if (error) {\n        setError(error.message)\n      }\n      // success-line-end\n    } finally {\n      setIsSigningIn(false)\n    }\n  }\n\n  const onSignUp = async () => {\n    try {\n      setIsSigningUp(true)\n      // success-line\n      setError(undefined)\n\n      // error-line\n      await signUp({ email, password })\n      // success-line-start\n      const { error } = await signUp({ email, password })\n      if (error) {\n        setError(error.message)\n      }\n      // success-line-end\n    } finally {\n      setIsSigningUp(false)\n    }\n  }\n  ...\n    return (\n    <Screen\n      contentContainerStyle={$root}\n      preset="auto"\n      safeAreaEdges={["top"]}\n    >\n      <View style={$container}>\n        <View style={$topContainer}>\n          <Image style={$logo} source={logo} resizeMode="contain" />\n        </View>\n        <View style={[$bottomContainer, $bottomContainerInsets]}>\n          // success-line\n          {error && <Text style={$errorText}>{error}</Text>}\n          <View>\n...\n\nconst $logo: ImageStyle = {\n  height: 88,\n  width: "100%",\n  marginBottom: spacing.xxl,\n}\n\n// success-line-start\nconst $errorText: TextStyle = {\n  color: colors.error,\n}\n// success-line-end\n\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Now if there is an issue with our authentication request, the user will be one step closer to understanding why. But why would we send authentication requests that we ",(0,s.jsx)(n.strong,{children:"know"})," are going to fail? We shouldn't and we'll fix that next. We're going to add some simple form validation to validate the values of our text inputs. We not only want to make sure that both text inputs have values, but that they are also valid values. (e.g. an email address)"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="/app/screens/SignInScreen.tsx"',children:'...\nexport const SignInScreen: FC<SignInScreenProps> = observer(function SignInScreen() {\n  const $bottomContainerInsets = useSafeAreaInsetsStyle(["bottom"])\n  const { signIn, signUp } = useAuth()\n  const [email, setEmail] = useState("")\n  const [password, setPassword] = useState("")\n  // success-line\n  const [validationErrors, setValidationErrors] = useState<Map<string, string>>(new Map())\n...\n  // success-line-start\n  const validateForm = () => {\n    const errors: Map<string, string> = new Map()\n\n    if (!email || email.split("@").length !== 2) {\n      errors.set("Email", "must be valid email")\n    }\n\n    if (!password) {\n      errors.set("Password", "cannot be blank")\n    }\n\n    return errors\n  }\n  // success-line-end\n\n  const onSignIn = async () => {\n    try {\n      setIsSigningIn(true)\n      setError(undefined)\n\n      // success-line-start\n      const errors = validateForm()\n      setValidationErrors(errors)\n      if (errors.size > 0) return\n      // success-line-end\n\n      const { error } = await signIn({ email, password })\n      if (error) {\n        setError(error.message)\n      }\n    } finally {\n      setIsSigningIn(false)\n    }\n  }\n\n  const onSignUp = async () => {\n    try {\n      setIsSigningUp(true)\n      setError(undefined)\n\n      // success-line-start\n      const errors = validateForm()\n      setValidationErrors(errors)\n      if (errors.size > 0) return\n      // success-line-end\n\n      const { error } = await signUp({ email, password })\n      if (error) {\n        setError(error.message)\n      }\n    } finally {\n      setIsSigningUp(false)\n    }\n  }\n...\n          <View>\n            <TextField\n              containerStyle={$textField}\n              label="Email"\n              autoCapitalize="none"\n              defaultValue={email}\n              onChangeText={setEmail}\n              readOnly={isLoading}\n              // success-line-start\n              helper={validationErrors.get("Email")}\n              status={validationErrors.get("Email") ? "error" : undefined}\n              // success-line-end\n            />\n            <TextField\n              containerStyle={$textField}\n              label="Password"\n              autoCapitalize="none"\n              defaultValue={password}\n              secureTextEntry\n              onChangeText={setPassword}\n              readOnly={isLoading}\n              // success-line-start\n              helper={validationErrors.get("Password")}\n              status={validationErrors.get("Password") ? "error" : undefined}\n              // success-line-end\n            />\n...\n'})}),"\n",(0,s.jsxs)(n.p,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Checkpoint:"})," At this point, everything is working as expected and we're giving the user valuable feedback throughout the process."]}),"\n",(0,s.jsx)(n.p,{children:"Before we wrap this up, there is one more thing we should do for the user experience of our sign up and sign in form."}),"\n",(0,s.jsx)(n.h2,{id:"form--input-affordances",children:"Form & Input Affordances"}),"\n",(0,s.jsx)(n.p,{children:"These are the little details that help our UI be a bit more precise, reduce mistakes, and help guide the user through the process. Tweaks like these have outsized benefits for the size of the code change."}),"\n",(0,s.jsxs)(n.p,{children:["One such detail is already in place; ",(0,s.jsx)(n.code,{children:'autoCapitalize="none"'}),". If you've ever tried to put in your email address only to frustratingly have the first character continually capitalized, this was the culprit."]}),"\n",(0,s.jsx)(n.h3,{id:"keyboard-type--auto-complete",children:"Keyboard Type & Auto Complete"}),"\n",(0,s.jsxs)(n.p,{children:["We have an email address as our first text input. Let's use the keyboard that's specific for that by setting the ",(0,s.jsx)(n.code,{children:"inputMode"})," and setup auto complete for these fields for use with autofill:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="/app/screens/SignInScreen.tsx"',children:'...\n            <TextField\n              autoCapitalize="none"\n              // success-line-start\n              autoComplete="email"\n              autoCorrect={false}\n              // success-line-end\n              containerStyle={$textField}\n              defaultValue={email}\n              helper={validationErrors.get("Email")}\n              // success-line\n              inputMode="email"\n              label="Email"\n              onChangeText={setEmail}\n              readOnly={isLoading}\n              status={validationErrors.get("Email") ? "error" : undefined}\n            />\n             <TextField\n              autoCapitalize="none"\n              // success-line-start\n              autoComplete="current-password"\n              autoCorrect={false}\n              // success-line-end\n              containerStyle={$textField}\n              defaultValue={password}\n              helper={validationErrors.get("Password")}\n              label="Password"\n              onChangeText={setPassword}\n              readOnly={isLoading}\n              secureTextEntry\n              status={validationErrors.get("Password") ? "error" : undefined}\n            />\n...\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["We're using ",(0,s.jsx)(n.code,{children:"current-password"}),' for auto complete for the password field since the sign in flow will be used more frequently by the user. If you split out the "Sign Up" into its own form, use ',(0,s.jsx)(n.code,{children:"new-password"})," to give autofill a better cue for that flow. ",(0,s.jsxs)(n.a,{href:"https://reactnative.dev/docs/textinput#autocomplete",children:["Read the ",(0,s.jsx)(n.code,{children:"autoComplete"})," docs for all of the available options and support"]}),"."]})}),"\n",(0,s.jsx)(n.h3,{id:"keyboard-flow",children:"Keyboard Flow"}),"\n",(0,s.jsx)(n.p,{children:'We can also setup directives to display the "Next" and "Done" buttons on the keyboard (return key) when the user has certain fields focused. We can also direct the cursor around or trigger events when those buttons are pressed:'}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:'When the "Email" field is focused, set the return key to read "Next".'}),"\n",(0,s.jsx)(n.li,{children:'When the "Next" return key is pressed, focus the "Password" field.'}),"\n",(0,s.jsx)(n.li,{children:'When the "Password" field is focused, set the return key to read "Done"'}),"\n",(0,s.jsx)(n.li,{children:'When the "Done" return key is pressed, trigger the sign in process.'}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="/app/screens/SignInScreen.tsx"',children:'// error-line\nimport React, { FC, useState } from "react"\n// success-line\nimport React, { FC, useRef, useState } from "react"\nimport { observer } from "mobx-react-lite"\n// error-line\nimport { Image, ImageStyle, Pressable, TextStyle, View, ViewStyle } from "react-native"\n// success-line\nimport { Image, ImageStyle, Pressable, TextInput, TextStyle, View, ViewStyle } from "react-native"\n...\nexport const SignInScreen: FC<SignInScreenProps> = observer(function SignInScreen() {\n  ...\n  const isLoading = isSigningIn || isSigningUp\n\n  // success-line\n  const passwordInput = useRef<TextInput>(null)\n\n  const onSignIn = async () => {\n...\n          <View>\n            <TextField\n              autoCapitalize="none"\n              autoComplete="email"\n              autoCorrect={false}\n              containerStyle={$textField}\n              defaultValue={email}\n              helper={validationErrors.get("Email")}\n              inputMode="email"\n              label="Email"\n              onChangeText={setEmail}\n              // success-line\n              onSubmitEditing={() => passwordInput.current?.focus()}\n              readOnly={isLoading}\n              // success-line\n              returnKeyType="next"\n              status={validationErrors.get("Email") ? "error" : undefined}\n            />\n            <TextField\n              autoCapitalize="none"\n              autoComplete="current-password"\n              autoCorrect={false}\n              containerStyle={$textField}\n              defaultValue={password}\n              helper={validationErrors.get("Password")}\n              label="Password"\n              onChangeText={setPassword}\n              // success-line\n              onSubmitEditing={onSignIn}\n              readOnly={isLoading}\n              ref={passwordInput}\n              // success-line\n              returnKeyType="done"\n              secureTextEntry\n              status={validationErrors.get("Password") ? "error" : undefined}\n            />\n          </View>\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"Once the props for the component get long enough, alphabetizing them can help make that a bit more manageable."})}),"\n",(0,s.jsx)(n.h3,{id:"show-password",children:"Show Password"}),"\n",(0,s.jsx)(n.p,{children:"Thanks to Ignite's prebuilt components, adding this little bit of functionality is pretty simple. Here we'll use the demo code that Ignite projects generate with; unless you opt-out like we did."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",metastring:'title="/app/screens/SignInScreen.tsx"',children:'// error-line\nimport React, { ComponentType, FC, useRef, useState } from "react"\n// success-line\nimport React, { ComponentType, FC, useMemo, useRef, useState } from "react"\nimport { observer } from "mobx-react-lite"\nimport {\n  Image,\n  ImageStyle,\n  Pressable,\n  TextInput,\n  TextStyle,\n  View,\n  ViewStyle,\n} from "react-native"\nimport { AppStackParamList, AppStackScreenProps } from "app/navigators"\n// error-line\nimport { Button, Screen, Text, TextField } from "app/components"\n// success-line-start\nimport {\n  Button,\n  Icon,\n  Screen,\n  Text,\n  TextField,\n  TextFieldAccessoryProps,\n} from "app/components"\n// success-line-end\n...\nexport const SignInScreen: FC<SignInScreenProps> = observer(function SignInScreen() {\n  ...\n  const [email, setEmail] = useState("")\n  const [password, setPassword] = useState("")\n  // success-line\n  const [isPasswordHidden, setIsPasswordHidden] = useState(true)\n  ...\n  // success-line-start\n  const PasswordRightAccessory: ComponentType<TextFieldAccessoryProps> = useMemo(\n    () =>\n      function PasswordRightAccessory(props: TextFieldAccessoryProps) {\n        return (\n          <Icon\n            icon={isPasswordHidden ? "view" : "hidden"}\n            color={colors.palette.neutral800}\n            containerStyle={props.style}\n            size={20}\n            onPress={() => setIsPasswordHidden(!isPasswordHidden)}\n          />\n        )\n      },\n    [isPasswordHidden],\n  )\n  // success-line-end\n\n  return (\n    <Screen\n      contentContainerStyle={$root}\n      preset="auto"\n      safeAreaEdges={["top"]}\n    >\n  ...\n              <TextField\n              autoCapitalize="none"\n              autoComplete="current-password"\n              autoCorrect={false}\n              containerStyle={$textField}\n              defaultValue={password}\n              helper={validationErrors.get("Password")}\n              labelTx="common.password"\n              onChangeText={setPassword}\n              onSubmitEditing={onSubmit}\n              readOnly={isLoading}\n              ref={passwordInput}\n              returnKeyType="send"\n              // error-line\n              secureTextEntry\n              // success-line-start\n              RightAccessory={PasswordRightAccessory}\n              secureTextEntry={isPasswordHidden}\n              // success-line-end\n              status={validationErrors.get("Password") ? "error" : undefined}\n            />\n  ...\n'})}),"\n",(0,s.jsx)(n.h2,{id:"-congratulations",children:"\ud83c\udf89 Congratulations!"}),"\n",(0,s.jsx)(n.p,{children:"You now have an application that can sign users up, in, and out that handles token refresh, listens for background session changes, stores the user's session securely, handles error & loading states, and has the proper form affordances for your workflows."})]})}function u(e={}){const{wrapper:n}={...(0,i.M)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},2172:(e,n,t)=>{t.d(n,{I:()=>a,M:()=>r});var s=t(1504);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);